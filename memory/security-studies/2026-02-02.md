# Deep Dive: Reentrancy Attacks ‚Äî The Vulnerability That Won't Die
**Date:** 2026-02-02
**Study Type:** Vulnerability Pattern Deep-Dive
**Relevance:** CRITICAL for Cantina bug bounties ‚Äî reentrancy accounts for $300M+ losses since Jan 2024

---

## üìä Impact Summary

| Metric | Value |
|--------|-------|
| Total losses (2024) | $35.7M across 22 incidents |
| Total losses since 2016 | $1B+ cumulative |
| OWASP Smart Contract Top 10 rank | #5 (SC05:2025) |
| Most recent major attack (as of research date) | GemPad, Dec 17 2024 ($1.9M) |
| Biggest 2024 attack | Penpie, Sep 3 2024 ($27M) |
| Biggest all-time reentrancy | The DAO, Jun 2016 (3.6M ETH, ~$60M at the time) |

---

## üî¨ The 5 Types of Reentrancy Attacks

### Type 1: Single-Function Reentrancy (Classic)
**The OG.** External call before state update in the same function.

```solidity
// VULNERABLE ‚Äî state update AFTER external call
contract Vulnerable {
    mapping (address => uint) private balances;

    function withdraw() public {
        uint amount = balances[msg.sender];
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
        balances[msg.sender] = 0; // TOO LATE ‚Äî attacker already re-entered
    }
}

// ATTACKER exploits via fallback/receive
contract Attacker {
    Vulnerable public target;
    
    constructor(address _target) {
        target = Vulnerable(_target);
    }
    
    function attack() external payable {
        target.deposit{value: 1 ether}();
        target.withdraw();
    }
    
    receive() external payable {
        if (address(target).balance >= 1 ether) {
            target.withdraw(); // Re-enter before balance zeroed
        }
    }
}
```

**Key insight:** The `msg.sender.call{value: amount}("")` triggers the attacker's `receive()` function, which calls `withdraw()` again while `balances[msg.sender]` is still the original amount.

### Type 2: Cross-Function Reentrancy
**Two functions share state, attacker enters one during the other's execution.**

```solidity
contract Vulnerable {
    mapping (address => uint) private balances;

    function transfer(address to, uint amount) public {
        if (balances[msg.sender] >= amount) {
            balances[to] += amount;
            balances[msg.sender] -= amount;
        }
    }

    function withdraw() public {
        uint amount = balances[msg.sender];
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
        balances[msg.sender] = 0;
    }
}
```

**Attack flow:**
1. Attacker calls `withdraw()`
2. During the ETH transfer callback, attacker calls `transfer()` instead
3. Since `balances[msg.sender]` hasn't been zeroed yet, transfer succeeds
4. Attacker gets both the withdrawal AND transfers their balance to another address
5. Repeat from that address

**Critical lesson for auditors:** A `nonReentrant` guard on `withdraw()` alone is NOT enough if `transfer()` shares the same state but lacks the guard!

### Type 3: Cross-Contract Reentrancy
**State shared between multiple contracts; attacker exploits inconsistency across contract boundaries.**

```solidity
// Contract A manages balances
contract Bank {
    mapping (address => uint) public balances;
    
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw() public nonReentrant {
        uint amount = balances[msg.sender];
        (bool success, ) = payable(msg.sender).call{value: amount}("");
        require(success);
        balances[msg.sender] = 0; // Updated AFTER external call
    }
}

// Contract B relies on Bank's balance data
contract BankConsumer {
    Bank private bank;
    
    function getBalance(address account) public view returns (uint256) {
        return bank.balances(account); // Reads stale data during reentrancy!
    }
}
```

**Attack:** During `withdraw()` callback, attacker interacts with `BankConsumer`. The Bank still shows the pre-withdrawal balance. BankConsumer makes decisions based on stale data (e.g., granting collateral, shares, etc.).

**Why it's dangerous:** `ReentrancyGuard` only protects the contract it's in. It can't protect other contracts that read its state.

### Type 4: Read-Only Reentrancy ‚ö†Ô∏è (HARDEST TO DETECT)
**View functions report stale values during reentrancy ‚Äî no state modification needed.**

This is the most subtle and currently most exploited variant. Key example: **Curve's `get_virtual_price()`**

```python
# Vyper - Curve Pool (simplified)
@nonreentrant('lock')
def remove_liquidity(_amount: uint256, _min_amounts: uint256[N_COINS]):
    # Burns LP tokens (decreases total supply)
    CurveToken(lp_token).burnFrom(msg.sender, _amount)
    
    # Sends underlying tokens to user
    for i in range(N_COINS):
        if i == 0:
            raw_call(msg.sender, b"", value=value)  # ‚Üê ETH transfer = callback!
        else:
            ERC20(self.coins[1]).transfer(msg.sender, value)

# This view function has NO reentrancy guard
@view
@external
def get_virtual_price() -> uint256:
    D: uint256 = self.get_D(self._balances(), self._A())
    token_supply: uint256 = ERC20(self.lp_token).totalSupply()
    return D * PRECISION / token_supply
    # ‚ö†Ô∏è During remove_liquidity callback:
    # - LP supply already decreased (burn happened)
    # - But balances NOT fully updated (tokens still being sent)
    # - Result: inflated virtual_price!
```

**Attack pattern:**
1. Deposit large liquidity into Curve pool
2. Call `remove_liquidity()`
3. During ETH callback (before all balances update), `get_virtual_price()` returns inflated value
4. Use inflated price to exploit any protocol that trusts `get_virtual_price()` (lending, collateral valuation)
5. Profit

**Affected protocols (2022-2023):** MakerDAO, Enzyme, Abracadabra, TribeDAO, Opyn, QuickSwap Lend ($220K), dForce, and many others using Curve LP as price oracle.

**Defense for integrators:**
```solidity
// Trigger Curve's reentrancy lock to check if we're in mid-execution
try pool.withdraw_admin_fees() {} catch {
    revert("Curve pool is mid-execution ‚Äî price unreliable");
}
// Or: check if Curve's reentrancy lock is active (if exposed publicly)
```

### Type 5: Cross-Chain Reentrancy
**Exploits async messaging between chains in bridge protocols.** Less common but growing threat with L2 proliferation.

- Similar mechanics to cross-contract reentrancy but across blockchain boundaries
- Complexity increases due to message passing delays and different execution environments
- Interoperability protocols and DEXs operating across multiple chains are at risk

---

## üèóÔ∏è Major Case Studies

### Case Study 1: Penpie ‚Äî $27M (September 3, 2024)
**The biggest reentrancy exploit of 2024.**

**Protocol:** Penpie (yield farming on Pendle Finance)

**Root Cause ‚Äî TWO critical issues:**
1. Missing `nonReentrant` on `batchHarvestMarketRewards()` 
2. Permissionless market creation (no validation of Pendle markets)

**Attack Flow:**
1. **Create fake market:** Attacker deploys malicious SY token contract, creates fake Pendle Market
2. **Flash loan:** Borrows agETH, rswETH, egETH, wstETH from Balancer
3. **Reentrancy via fake market:** Calls `batchHarvestMarketRewards()` with malicious market
   - Contract calls `PendleMarket::redeemRewards()` on fake market
   - Fake market reenters via `depositMarket()` (which HAD nonReentrant, but it was bypassed because `batchHarvestMarketRewards` didn't!)
   - Flash-loaned tokens deposited into legitimate markets during callback
4. **Balance inflation:** Contract measures balance before/after, sees increased balance
   - Incorrectly assumes increase = rewards (actually it was the attacker's deposits)
5. **Claim "rewards":** Attacker is sole depositor in fake market ‚Üí claims all "rewards"
6. **Withdraw & profit:** Convert Pendle Market tokens back, repay flash loan, keep $27M

**Key Auditing Lessons:**
- ‚ö†Ô∏è If ANY function in a cross-function flow lacks reentrancy protection, the entire flow is vulnerable
- ‚ö†Ô∏è Permissionless creation of entities (markets, pools, tokens) that interact with protocol logic = massive attack surface
- ‚ö†Ô∏è Balance-before/after patterns are vulnerable if deposits can happen mid-execution
- The protocol HAD been audited ‚Äî but this was missed!

### Case Study 2: Curve/Vyper Compiler Bug ‚Äî $70M (July 30, 2023)
**A compiler-level reentrancy vulnerability.**

**The Bug:** Vyper compiler versions 0.2.15, 0.2.16, and 0.3.0 had a bug where `@nonreentrant('lock')` decorators **silently failed**. The reentrancy lock mechanism was broken at the compiler level.

**Affected pools:** pETH/ETH ($11M), msETH/ETH ($3.4M), alETH/ETH ($22.6M), CRV/ETH ($24.7M)

**Attack pattern (pETH/ETH example):**
1. Flash loan 80,000 WETH from Balancer, unwrap to ETH
2. Add 40,000 ETH as liquidity ‚Üí receive LP tokens
3. Remove liquidity (burns LP, but reentrancy lock BROKEN)
4. During ETH callback, add 40,000 ETH again
5. LP tokens minted with pre-burn balances (stale supply denominator)
6. Result: way more LP tokens than deserved
7. Redeem inflated LP tokens for massive profit

**Key Auditing Lesson:** 
- ‚ö†Ô∏è Don't just check that reentrancy guards exist ‚Äî verify the COMPILER actually enforces them
- ‚ö†Ô∏è Vyper's `@nonreentrant` is NOT equivalent to OZ's `nonReentrant` ‚Äî different implementations, different failure modes
- This was a ZERO-DAY ‚Äî the bug existed since 2021, was accidentally fixed in 0.3.1, but not recognized until July 2023

### Case Study 3: GemPad ‚Äî $1.9M (December 17, 2024)
**Template-level reentrancy affecting 27 projects.**

**Protocol:** GemPad (no-code token launchpad, LP locker)

**Vulnerability:** `collectFees()` function in GempadLock contract made external call (token transfer) before updating fee payment state.

**Attack:** 
1. Attacker creates malicious ERC-20 token with custom `transfer()` that reenters `collectFees()`
2. During fee collection's token transfer, malicious transfer callback reenters
3. Creates new LP lock without paying fees
4. Repeats to drain locked assets

**Exploited across:** Ethereum, BNB Chain, Base (same vulnerable template on all three)

**Key Lesson:** 
- ‚ö†Ô∏è Template/infrastructure vulnerabilities cascade to ALL downstream projects
- ‚ö†Ô∏è Even if individual token contracts are audited, if the underlying platform has a bug, all users are affected
- 27 different projects compromised through one template vulnerability

---

## üõ°Ô∏è Defense Strategies (Ranked by Effectiveness)

### 1. Checks-Effects-Interactions (CEI) Pattern ‚Äî FUNDAMENTAL
```solidity
function withdraw(uint amount) public {
    // 1. CHECKS ‚Äî validate conditions
    require(balance[msg.sender] >= amount, "Insufficient");
    
    // 2. EFFECTS ‚Äî update state BEFORE any external call
    balance[msg.sender] -= amount;
    
    // 3. INTERACTIONS ‚Äî external calls LAST
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
    
    emit Withdrawal(msg.sender, amount);
}
```

### 2. OpenZeppelin ReentrancyGuard ‚Äî Essential Defense Layer
```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SecureProtocol is ReentrancyGuard {
    function withdraw() external nonReentrant {
        // Even if CEI is imperfect, this prevents re-entry
        uint balance = balances[msg.sender];
        require(balance > 0);
        balances[msg.sender] = 0;
        (bool success, ) = msg.sender.call{value: balance}("");
        require(success);
    }
}
```

**Limitation:** Only protects the contract it's in. Cross-contract reentrancy can bypass it.

### 3. Global Reentrancy Lock (For Multi-Contract Systems)
For protocols with shared state across contracts, use a global lock:
```solidity
contract GlobalLock {
    bool private _locked;
    
    modifier globalNonReentrant() {
        require(!_locked, "Global lock active");
        _locked = true;
        _;
        _locked = false;
    }
}
```

### 4. Read-Only Reentrancy Defense
For protocols integrating with Curve, Balancer, or similar:
```solidity
// Check if the source protocol is mid-execution before reading prices
function getSecurePrice() external view returns (uint256) {
    // Attempt to trigger the pool's reentrancy lock
    // If it reverts, we know we're in a reentrancy context
    try pool.withdraw_admin_fees() {} catch {
        revert("Price oracle unreliable ‚Äî pool mid-execution");
    }
    return pool.get_virtual_price();
}
```

### 5. Use `transfer()` or `send()` Instead of `call()`
- `transfer()` and `send()` only forward 2300 gas (not enough for reentrancy)
- BUT: This is now considered an anti-pattern because gas costs can change after EVM upgrades
- Modern best practice: Use `call()` + CEI + ReentrancyGuard

---

## üîç Auditor's Detection Checklist

### Red Flags to Hunt For:

1. **Any `.call{value: ...}("")`** ‚Äî external ETH transfer, potential callback
2. **`safeTransferFrom()` on ERC-721/ERC-1155** ‚Äî calls `onERC721Received()` / `onERC1155Received()`
3. **`safeMint()`** ‚Äî calls `onERC721Received()` on recipient
4. **ERC-777 token interactions** ‚Äî hooks called on send/receive
5. **State changes AFTER any of the above** ‚Äî CEI violation
6. **`nonReentrant` on some functions but not all** ‚Äî cross-function attack surface
7. **Balance-before/after patterns** ‚Äî vulnerable if deposits can happen mid-execution
8. **View functions reading shared state** ‚Äî read-only reentrancy risk
9. **Permissionless entity creation** (pools, markets, tokens) interacting with core logic
10. **Vyper contracts on versions 0.2.15-0.3.0** ‚Äî broken reentrancy locks!

### Slither Reentrancy Detectors:
```bash
# Run all reentrancy checks
slither . --detect reentrancy-eth,reentrancy-no-eth,reentrancy-benign,reentrancy-events

# Specific detectors:
# reentrancy-eth         ‚Äî reentrancy that steals ETH (HIGH severity)
# reentrancy-no-eth      ‚Äî reentrancy that steals ERC-20 tokens
# reentrancy-benign      ‚Äî reentrancy with no obvious impact (review anyway!)
# reentrancy-events      ‚Äî events emitted after external calls (may indicate CEI violation)
# reentrancy-unlimited-gas ‚Äî reentrancy using call() instead of transfer()
```

### Foundry Testing Pattern:
```solidity
// Test for reentrancy with a malicious receiver
contract ReentrancyTest is Test {
    function testReentrancyAttack() public {
        AttackerContract attacker = new AttackerContract(address(target));
        
        // Fund the target with some ETH
        deal(address(target), 10 ether);
        
        // Fund attacker with minimum deposit
        deal(address(attacker), 1 ether);
        
        // Execute attack
        attacker.attack{value: 1 ether}();
        
        // If attacker has more than 1 ether, reentrancy succeeded
        assertLe(address(attacker).balance, 1 ether, "REENTRANCY VULNERABILITY!");
    }
}
```

---

## üéØ Where Reentrancy Hides in Modern DeFi

| Context | Trigger Mechanism | Often Missed? |
|---------|-------------------|---------------|
| ETH withdrawals | `receive()`/`fallback()` | Rarely |
| ERC-721 minting | `onERC721Received()` via `safeMint()` | Sometimes |
| ERC-1155 transfers | `onERC1155Received()` | Sometimes |
| ERC-777 transfers | Send/receive hooks | Often |
| Reward harvesting | External market calls | **Very often** |
| LP token operations | Add/remove liquidity callbacks | **Very often** |
| View function reads | Cross-contract state queries | **Almost always** |
| Proxy delegatecall | Execution context manipulation | Often |

---

## üìö Key Resources

- **[pcaversaccio/reentrancy-attacks](https://github.com/pcaversaccio/reentrancy-attacks)** ‚Äî Complete chronological list of all reentrancy attacks
- **[Smart Contract Security Field Guide](https://scsfg.io/hackers/reentrancy/)** ‚Äî Excellent technical reference with code examples
- **[Cyfrin Updraft](https://updraft.cyfrin.io/)** ‚Äî Free security course with reentrancy module
- **[SunWeb3Sec/DeFiVulnLabs](https://github.com/SunWeb3Sec/DeFiVulnLabs)** ‚Äî Hands-on vulnerability lab
- **[jcsec-security/all-things-reentrancy](https://github.com/jcsec-security/all-things-reentrancy)** ‚Äî Workshop with template attacker contracts for each type
- **[ChainSecurity ‚Äî Curve LP Oracle Post-Mortem](https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/)** ‚Äî Best reference for read-only reentrancy
- **[Three Sigma ‚Äî Penpie Analysis](https://threesigma.xyz/blog/exploit/penpie-reentrancy-exploit-analysis)** ‚Äî Detailed 2024 case study

---

## üí° Key Takeaways for Cantina Bug Bounties

1. **Read-only reentrancy is the lowest-hanging fruit right now** ‚Äî many protocols integrate Curve/Balancer LP tokens as price oracles without reentrancy protection on view functions
2. **Cross-function reentrancy is where the money is** ‚Äî look for shared state across functions where not all are guarded
3. **Permissionless market/pool creation + reward harvesting = high-value target** (Penpie pattern)
4. **Check ALL callback triggers**, not just ETH transfers ‚Äî ERC-721 safeMint, ERC-1155, ERC-777 hooks
5. **Balance-before/after measurement patterns are suspect** if ANY deposit/transfer can happen between measurements
6. **Compiler-level bugs exist** ‚Äî verify Vyper version, verify that reentrancy guards actually work
7. **Template/infrastructure audits** can find bugs affecting dozens of downstream projects (GemPad pattern)
